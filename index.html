<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <!-- Mobile-friendly viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Atlas's P2P Communication</title>
    <style>
      /* --- BASE THEME (Default Dark Mode) --- */
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background-color: #0d0d0d;
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        color: #fff;
        overflow: auto;
      }
      .container {
        width: 95%;
        max-width: 800px;
        background: rgba(10, 10, 30, 0.9);
        border: 2px solid #7b2cbf;
        box-shadow: 0 0 15px #4361ee;
        border-radius: 10px;
        padding: 20px;
        box-sizing: border-box;
        margin: 10px;
        transition: box-shadow 0.3s, background 0.3s;
      }
      .container:hover {
        box-shadow: 0 0 25px #4361ee;
      }

      /* --- LOGO & ANIMATION --- */
      @keyframes glowPulse {
        0% {
          filter: drop-shadow(0 0 5px #4361ee);
        }
        50% {
          filter: drop-shadow(0 0 15px #7b2cbf);
        }
        100% {
          filter: drop-shadow(0 0 5px #4361ee);
        }
      }
      #logo {
        width: 150px;
        margin-bottom: 10px;
        animation: glowPulse 2s ease-in-out infinite;
      }

      /* --- HEADINGS & SECTIONS --- */
      h1,
      h2 {
        text-align: center;
        margin: 10px 0;
      }
      .section {
        background: rgba(20, 20, 50, 0.8);
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        box-sizing: border-box;
      }
      p {
        margin: 10px 0;
      }

      /* --- TEXTAREAS & INPUTS --- */
      textarea,
      input[type="text"],
      input[type="number"],
      select {
        width: 100%;
        border: none;
        border-radius: 5px;
        padding: 10px;
        margin-bottom: 10px;
        box-sizing: border-box;
        background: rgba(255, 255, 255, 0.1);
        color: inherit;
        font-family: inherit;
        transition: background 0.3s;
      }
      textarea:focus,
      input[type="text"]:focus,
      input[type="number"]:focus,
      select:focus {
        background: rgba(255, 255, 255, 0.2);
        outline: none;
      }
      textarea {
        height: 100px;
        resize: none;
      }

      /* --- BUTTONS --- */
      button {
        padding: 10px 20px;
        border: none;
        border-radius: 5px;
        background-color: #7b2cbf;
        color: #fff;
        font-weight: bold;
        cursor: pointer;
        margin: 5px;
        box-shadow: 0 0 10px #4361ee;
        transition: background-color 0.3s, transform 0.1s;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }
      button:hover {
        background-color: #5a189a;
      }
      button:active {
        transform: scale(0.98);
      }

      /* --- CHAT AREA --- */
      #chatArea {
        max-height: 300px;
        overflow-y: auto;
        background: rgba(20, 20, 50, 0.9);
        padding: 10px;
        border-radius: 5px;
        text-align: left;
        box-sizing: border-box;
      }
      .message {
        margin: 10px 0;
        word-wrap: break-word;
      }
      .message.self {
        text-align: right;
      }
      .timestamp {
        font-size: 0.8em;
        color: #ccc;
        margin-left: 5px;
      }
      #typingIndicator {
        font-style: italic;
        color: #ccc;
        height: 20px;
      }

      /* --- ROLE & NAME SELECTION --- */
      #roleSelection {
        display: flex;
        gap: 10px;
        justify-content: center;
        margin-bottom: 15px;
        flex-wrap: wrap;
      }
      #nameSection {
        background: rgba(20, 20, 50, 0.8);
        padding: 10px;
        border-radius: 5px;
        margin-bottom: 20px;
        text-align: center;
        display: none;
      }

      /* --- MESSAGE CONTAINER --- */
      #messageContainer {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
        gap: 5px;
      }
      #messageInput {
        flex: 1;
        height: 40px;
        line-height: 40px;
        margin: 0;
        padding: 0 10px;
        box-sizing: border-box;
      }
      #sendMessage {
        width: 40px;
        height: 40px;
        font-size: 1.2em;
        margin: 0;
        padding: 0;
        line-height: 40px;
      }

      /* --- EMOJI MENU --- */
      #emojiMenu {
        display: none;
        flex-wrap: wrap;
        background: rgba(20, 20, 50, 0.9);
        border: 1px solid #7b2cbf;
        border-radius: 5px;
        padding: 5px;
        max-height: 100px;
        overflow-y: auto;
        margin-bottom: 10px;
      }
      #emojiMenu span {
        font-size: 1.5em;
        padding: 5px;
        cursor: pointer;
        transition: background 0.2s;
      }
      #emojiMenu span:hover {
        background: rgba(123, 44, 191, 0.2);
        border-radius: 3px;
      }

      /* --- CLEAR CHAT OPTIONS --- */
      #clearChatOptions {
        display: none;
        gap: 10px;
        margin: 5px 0;
      }

      /* --- SETTINGS MENU --- */
      #settingsMenu {
        background: rgba(20, 20, 50, 0.9);
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        box-sizing: border-box;
        display: none;
      }

      /* --- Light Mode Overrides --- */
      body.light-mode {
        background-color: #f0f0f0;
        color: #000;
      }
      body.light-mode .container {
        background: rgba(245, 245, 245, 0.9);
        box-shadow: 0 0 15px #999;
        color: #000;
      }
      body.light-mode .section {
        background: rgba(230, 230, 230, 0.8);
        color: #000;
      }
      body.light-mode textarea,
      body.light-mode input[type="text"],
      body.light-mode input[type="number"],
      body.light-mode select {
        background: rgba(255, 255, 255, 0.8);
        color: #000;
      }
      body.light-mode button {
        background-color: #7b2cbf;
        color: #fff;
      }
      body.light-mode #emojiMenu {
        background: rgba(230, 230, 230, 0.9);
        color: #000;
      }
      body.light-mode #chatArea {
        background: #fff;
        color: #000;
      }
      body.light-mode #typingIndicator {
        color: #333;
      }
      body.light-mode .message {
        color: #000;
      }
      body.light-mode .message.self {
        color: #000;
      }
      body.light-mode .timestamp {
        color: #666;
      }
      body.light-mode #connectionStatus {
        color: #000;
      }
      /* Additional override for settings menu in light mode */
      body.light-mode #settingsMenu,
      body.light-mode #settingsMenu label,
      body.light-mode #settingsMenu input,
      body.light-mode #settingsMenu select,
      body.light-mode #settingsMenu button {
        background: #fff !important;
        color: #000 !important;
        border: 1px solid #ccc;
      }

      /* --- EXIT COUNTDOWN --- */
      #exitCountdown {
        display: none;
        text-align: center;
        font-size: 1.2em;
        margin-top: 10px;
      }

      /* --- CONNECTION STATUS --- */
      #connectionStatus {
        text-align: center;
        margin-bottom: 10px;
        font-weight: bold;
      }

      /* --- ID DISPLAY --- */
      #clientIdDisplay {
        text-align: center;
        margin: 5px 0;
        font-size: 1.1em;
      }

      /* --- SERVER STATUS DIV --- */
      #serverStatus {
        text-align: center;
        margin-bottom: 10px;
        font-style: italic;
      }

      /* --- RESPONSIVE (MOBILE) --- */
      @media (max-width: 600px) {
        .container {
          padding: 15px;
        }
        #roleSelection {
          flex-direction: column;
        }
        button {
          width: 100%;
          margin: 5px 0;
        }
        #messageContainer {
          flex-direction: row;
        }
        #sendMessage {
          width: 40px;
          height: 40px;
        }
        #chatArea {
          max-height: 200px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Logo -->
      <div style="text-align: center">
        <img id="logo" src="image.webp" alt="Atlas's P2P Communication Logo" />
      </div>
      <h1>Atlas's P2P Communication</h1>

      <!-- A status message for connecting/spinning up the server -->
      <div id="serverStatus"></div>

      <!-- Signaling Section -->
      <div id="signaling" class="section">
        <!-- Role Selection -->
        <div id="roleSelection">
          <button id="startHost">Start as Host</button>
          <button id="joinHost">Join as Peer</button>
        </div>

        <!-- Display Name Input Section -->
        <div id="nameSection">
          <input type="text" id="userNameInput" placeholder="Enter Your Display Name" />
          <button id="setUserName">Set Name</button>
        </div>

        <!-- Show the user’s unique client ID once connected -->
        <div id="clientIdDisplay" style="display: none;">
          <strong>Your ID:</strong> <span id="clientIdValue">N/A</span>
        </div>

        <!-- For HOST: Type your peer's ID -->
        <div id="hostSection" style="display: none;">
          <p><strong>Peer's ID:</strong></p>
          <input type="text" id="peerIdInput" placeholder="Enter the peer's ID" />
          <button id="callPeer">Call Peer</button>
        </div>

        <!-- For PEER: Wait for an incoming offer -->
        <div id="peerSection" style="display: none;">
          <p>Waiting for incoming call from the Host...</p>
        </div>
      </div>

      <!-- Chat Section -->
      <div id="chat" class="section" style="display: none">
        <!-- Chat Header & Connection Status -->
        <h2 id="chatHeader">Chat</h2>
        <div id="connectionStatus">Status: Connecting...</div>
        <div id="chatArea"></div>
        <div id="typingIndicator"></div>

        <!-- Message Input Area -->
        <div id="messageContainer">
          <input type="text" id="messageInput" placeholder="Type your message here..." />
          <button id="sendMessage">➤</button>
        </div>

        <!-- Menu Options: Emoji, Settings, Clear Chat -->
        <div style="display: flex; gap: 10px; align-items: center; margin-top: 10px; flex-wrap: wrap;">
          <button id="emojiToggle">Emoji</button>
          <button id="openSettings">Settings</button>
          <button id="clearChat">Clear Chat</button>
        </div>

        <!-- Emoji Menu -->
        <div id="emojiMenu">
          <span>😀</span>
          <span>😂</span>
          <span>😍</span>
          <span>😢</span>
          <span>😡</span>
          <span>👍</span>
          <span>👎</span>
          <span>🙏</span>
          <span>🎉</span>
          <span>🤔</span>
        </div>

        <!-- Clear Chat Options -->
        <div id="clearChatOptions">
          <button id="clearForMe">Clear for Me</button>
          <button id="clearForEveryone">Clear for Everyone</button>
          <button id="cancelClear">Cancel</button>
        </div>

        <!-- Exit Countdown Display -->
        <div id="exitCountdown"></div>
      </div>

      <!-- Settings Menu -->
      <div id="settingsMenu" class="section">
        <h2>Settings</h2>
        <label>Encryption Passphrase:</label>
        <input type="text" id="encryptionPassphraseInput" placeholder="Enter passphrase" value="default" />
        <label>Self-Destruct Timer (minutes):</label>
        <input type="number" id="selfDestructTimerInput" value="10" min="1" />
        <label>Theme:</label>
        <select id="themeSelect">
          <option value="default">Default (Dark Mode)</option>
          <option value="light">Light Mode</option>
        </select>
        <button id="saveSettings">Save Settings</button>
        <button id="closeSettings">Close</button>
      </div>
    </div>

    <script>
      /************************************************************
       * 1) Server Wake-Up & Connecting Animation
       ************************************************************/
      // Replace these with your own Render domain:
      const SIGNALING_SERVER_URL = "wss://p2p-secure-server.onrender.com";
      const HTTP_WAKE_URL = "https://p2p-secure-server.onrender.com"; // for a quick "fetch" to wake up

      const serverStatus = document.getElementById("serverStatus");

      let connectingDotsInterval;
      let connectionTimeout;

      function startConnectingAnimation() {
        let dotCount = 0;
        connectingDotsInterval = setInterval(() => {
          dotCount = (dotCount % 3) + 1; 
          let dots = ".".repeat(dotCount);
          serverStatus.textContent = "Connecting" + dots;
        }, 500);
      }

      function stopConnectingAnimation() {
        clearInterval(connectingDotsInterval);
      }

      function showLongWaitMessage() {
        serverStatus.textContent = "Still connecting... The server may be waking up. Please keep waiting or refresh the page.";
      }

      // We'll "ping" the server to try to wake it, then attempt the WebSocket
      function initiateServerConnection() {
        // Show "Connecting" with animated dots
        startConnectingAnimation();

        // If it takes >10 seconds, show a longer message
        connectionTimeout = setTimeout(showLongWaitMessage, 10000);

        // Attempt a quick fetch to wake the server's free tier
        fetch(HTTP_WAKE_URL)
          .then(() => {
            // Now connect to the WebSocket
            connectToSignalingServer();
          })
          .catch(() => {
            // Even if fetch fails, try WS anyway
            connectToSignalingServer();
          });
      }

      /************************************************************
       * 2) Connect to Signaling Server via WebSocket
       ************************************************************/
      let socket;
      let clientId = null;        // Assigned by server
      let userName = "Anonymous"; // Set by user
      let selectedRole = null;    // "host" or "peer"

      function connectToSignalingServer() {
        socket = new WebSocket(SIGNALING_SERVER_URL);

        socket.onopen = () => {
          console.log("WebSocket: Connected.");
          stopConnectingAnimation();
          clearTimeout(connectionTimeout);
          serverStatus.textContent = "Connected to server!";
          // Hide the message after 2 seconds
          setTimeout(() => {
            serverStatus.textContent = "";
          }, 2000);
        };

        socket.onmessage = (event) => {
          const msg = JSON.parse(event.data);
          handleSignalingMessage(msg);
        };

        socket.onerror = (err) => {
          console.error("WebSocket error:", err);
          stopConnectingAnimation();
          serverStatus.textContent = "Error connecting. The server might be waking up; please wait or refresh.";
        };

        socket.onclose = () => {
          console.warn("Socket closed. Possibly the server is sleeping or we got disconnected.");
          stopConnectingAnimation();
          serverStatus.textContent = "Disconnected. Server might be sleeping. Refresh or wait.";
        };
      }

      function handleSignalingMessage(msg) {
        if (msg.type === "welcome") {
          // The server assigned us a unique clientId
          clientId = msg.clientId;
          clientIdValue.textContent = clientId;
          document.getElementById("clientIdDisplay").style.display = "block";
        } else {
          switch (msg.type) {
            case "offer":
              onOffer(msg.from, msg.data);
              break;
            case "answer":
              onAnswer(msg.from, msg.data);
              break;
            case "candidate":
              onCandidate(msg.from, msg.data);
              break;
            default:
              console.log("Unknown WS message:", msg);
          }
        }
      }

      function sendToServer(target, type, data) {
        socket.send(JSON.stringify({ target, type, data }));
      }

      /************************************************************
       * 3) WebRTC / Chat Variables & Setup
       ************************************************************/
      let localConnection;
      let dataChannel;
      let peerId = "";          
      let typingTimeout;
      let typingSent = false;
      let selfDestructTime = 10;
      let encryptionPassphrase = "default";
      let encryptionKey = null;

      // DOM Refs
      const roleSelection = document.getElementById("roleSelection");
      const startHostButton = document.getElementById("startHost");
      const joinHostButton = document.getElementById("joinHost");
      const nameSection = document.getElementById("nameSection");
      const userNameInput = document.getElementById("userNameInput");
      const setUserNameButton = document.getElementById("setUserName");

      const clientIdDisplay = document.getElementById("clientIdDisplay");
      const clientIdValue = document.getElementById("clientIdValue");

      const hostSection = document.getElementById("hostSection");
      const peerIdInput = document.getElementById("peerIdInput");
      const callPeerButton = document.getElementById("callPeer");
      const peerSection = document.getElementById("peerSection");

      const chatDiv = document.getElementById("chat");
      const chatHeader = document.getElementById("chatHeader");
      const connectionStatus = document.getElementById("connectionStatus");
      const chatArea = document.getElementById("chatArea");
      const typingIndicator = document.getElementById("typingIndicator");

      const messageInput = document.getElementById("messageInput");
      const sendMessageButton = document.getElementById("sendMessage");
      const clearChatButton = document.getElementById("clearChat");
      const clearChatOptions = document.getElementById("clearChatOptions");
      const clearForMeButton = document.getElementById("clearForMe");
      const clearForEveryoneButton = document.getElementById("clearForEveryone");
      const cancelClearButton = document.getElementById("cancelClear");
      const emojiToggle = document.getElementById("emojiToggle");
      const emojiMenu = document.getElementById("emojiMenu");
      const openSettingsButton = document.getElementById("openSettings");
      const settingsMenu = document.getElementById("settingsMenu");
      const encryptionPassphraseInput = document.getElementById("encryptionPassphraseInput");
      const selfDestructTimerInput = document.getElementById("selfDestructTimerInput");
      const saveSettingsButton = document.getElementById("saveSettings");
      const closeSettingsButton = document.getElementById("closeSettings");
      const exitCountdown = document.getElementById("exitCountdown");
      const signalingDiv = document.getElementById("signaling");

      /************************************************************
       * 4) Role Selection & Name
       ************************************************************/
      startHostButton.addEventListener("click", () => {
        selectedRole = "host";
        if (userName === "Anonymous") {
          nameSection.style.display = "block";
        } else {
          showHostUI();
        }
      });

      joinHostButton.addEventListener("click", () => {
        selectedRole = "peer";
        if (userName === "Anonymous") {
          nameSection.style.display = "block";
        } else {
          showPeerUI();
        }
      });

      setUserNameButton.addEventListener("click", () => {
        const name = userNameInput.value.trim();
        if (name) {
          userName = name;
          nameSection.style.display = "none";
          if (selectedRole === "host") {
            showHostUI();
          } else {
            showPeerUI();
          }
        } else {
          alert("Please enter a valid display name.");
        }
      });

      function showHostUI() {
        roleSelection.style.display = "none";
        hostSection.style.display = "block";
        peerSection.style.display = "none";
      }
      function showPeerUI() {
        roleSelection.style.display = "none";
        peerSection.style.display = "block";
        hostSection.style.display = "none";
      }

      /************************************************************
       * 5) Creating the PeerConnection & DataChannel
       ************************************************************/
      function createPeerConnection() {
        localConnection = new RTCPeerConnection({
          iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
        });

        localConnection.onicecandidate = (event) => {
          if (event.candidate) {
            sendToServer(peerId, "candidate", event.candidate);
          }
        };

        localConnection.oniceconnectionstatechange = () => {
          connectionStatus.textContent = "Status: " + localConnection.iceConnectionState;
          if (
            localConnection.iceConnectionState === "disconnected" ||
            localConnection.iceConnectionState === "failed"
          ) {
            console.log("ICE disconnected/failed. Attempting restart...");
            localConnection.restartIce();
          }
        };

        localConnection.ondatachannel = (event) => {
          dataChannel = event.channel;
          setupDataChannel();
        };
      }

      function createDataChannel() {
        dataChannel = localConnection.createDataChannel("chat");
        setupDataChannel();
      }

      function setupDataChannel() {
        dataChannel.onopen = () => {
          console.log("Data channel open");
          // Hide signaling, show chat
          signalingDiv.style.display = "none";
          chatDiv.style.display = "block";
        };
        dataChannel.onmessage = (event) => {
          // Try to parse as JSON (for encryption)
          let incoming;
          try {
            incoming = JSON.parse(event.data);
          } catch {
            // If not JSON, just show raw text
            addMessage("Peer", event.data, false, new Date());
            return;
          }
          // If it's structured, handle the type
          handleIncomingMessage(incoming);
        };
      }

      /************************************************************
       * 6) Host Flow: createOffer -> send to Peer
       ************************************************************/
      async function startHostCall() {
        createPeerConnection();
        createDataChannel();

        try {
          const offer = await localConnection.createOffer();
          await localConnection.setLocalDescription(offer);
          sendToServer(peerId, "offer", offer);
        } catch (err) {
          console.error("Error creating offer:", err);
        }
      }
      callPeerButton.addEventListener("click", () => {
        peerId = peerIdInput.value.trim();
        if (!peerId) {
          alert("Please enter the peer's ID.");
          return;
        }
        startHostCall();
      });

      /************************************************************
       * 7) Peer Flow: onOffer -> setRemote -> createAnswer -> send
       ************************************************************/
      async function onOffer(from, offer) {
        peerId = from; 
        createPeerConnection();
        try {
          await localConnection.setRemoteDescription(offer);
          const answer = await localConnection.createAnswer();
          await localConnection.setLocalDescription(answer);
          sendToServer(peerId, "answer", answer);
        } catch (err) {
          console.error("Error handling offer:", err);
        }
      }

      async function onAnswer(from, answer) {
        try {
          await localConnection.setRemoteDescription(answer);
          console.log("Remote desc set (host side)");
        } catch (err) {
          console.error("Error setting remote desc:", err);
        }
      }

      async function onCandidate(from, candidate) {
        try {
          await localConnection.addIceCandidate(candidate);
        } catch (err) {
          console.error("Error adding ICE candidate:", err);
        }
      }

      /************************************************************
       * 8) Incoming Chat & System Messages
       ************************************************************/
      function handleIncomingMessage(msg) {
        if (msg.type === "chat") {
          if (msg.encrypted) {
            decryptMessage(msg.data)
              .then((plainText) => {
                addMessage(msg.name, plainText, false, new Date(msg.time));
              })
              .catch(() => {
                addMessage(msg.name, "[Decryption error]", false, new Date(msg.time));
              });
          } else {
            addMessage(msg.name, msg.text, false, new Date(msg.time));
          }
        } else if (msg.type === "typing") {
          showTypingIndicator(msg.name);
        } else if (msg.type === "clearEveryone") {
          clearChatArea();
          const sysMsg = document.createElement("div");
          sysMsg.className = "message";
          sysMsg.style.fontStyle = "italic";
          sysMsg.textContent = "Chat was cleared by " + msg.name;
          chatArea.appendChild(sysMsg);
          chatArea.scrollTop = chatArea.scrollHeight;
        } else if (msg.type === "leave") {
          const sysMsg = document.createElement("div");
          sysMsg.className = "message";
          sysMsg.style.fontStyle = "italic";
          sysMsg.textContent = msg.name + " has left the chat.";
          chatArea.appendChild(sysMsg);
          chatArea.scrollTop = chatArea.scrollHeight;
          messageInput.disabled = true;
          sendMessageButton.disabled = true;
          startExitCountdown();
        }
      }

      /************************************************************
       * 9) End-to-End Encryption
       ************************************************************/
      async function deriveKey(passphrase) {
        const enc = new TextEncoder();
        const keyMaterial = await window.crypto.subtle.importKey(
          "raw",
          enc.encode(passphrase),
          { name: "PBKDF2" },
          false,
          ["deriveKey"]
        );
        return window.crypto.subtle.deriveKey(
          {
            name: "PBKDF2",
            salt: enc.encode("fixedSalt"),
            iterations: 100000,
            hash: "SHA-256",
          },
          keyMaterial,
          { name: "AES-GCM", length: 256 },
          false,
          ["encrypt", "decrypt"]
        );
      }

      async function encryptMessage(plaintext) {
        if (!encryptionKey) {
          encryptionKey = await deriveKey(encryptionPassphrase);
        }
        const enc = new TextEncoder();
        const iv = window.crypto.getRandomValues(new Uint8Array(12));
        const encrypted = await window.crypto.subtle.encrypt(
          { name: "AES-GCM", iv },
          encryptionKey,
          enc.encode(plaintext)
        );
        return {
          iv: Array.from(iv),
          ciphertext: Array.from(new Uint8Array(encrypted)),
        };
      }

      async function decryptMessage(encryptedObj) {
        if (!encryptionKey) {
          encryptionKey = await deriveKey(encryptionPassphrase);
        }
        const { iv, ciphertext } = encryptedObj;
        const dec = new TextDecoder();
        const decrypted = await window.crypto.subtle.decrypt(
          { name: "AES-GCM", iv: new Uint8Array(iv) },
          encryptionKey,
          new Uint8Array(ciphertext)
        );
        return dec.decode(decrypted);
      }

      /************************************************************
       * 10) Sending Chat Messages
       ************************************************************/
      async function sendMessage() {
        const text = messageInput.value.trim();
        if (text && dataChannel && dataChannel.readyState === "open") {
          try {
            const encryptedData = await encryptMessage(text);
            const msg = {
              type: "chat",
              name: userName,
              encrypted: true,
              data: encryptedData,
              time: new Date().toISOString(),
            };
            dataChannel.send(JSON.stringify(msg));
            addMessage(userName, text, true, new Date());
            messageInput.value = "";
          } catch (err) {
            console.error("Encryption error:", err);
          }
        }
      }
      sendMessageButton.addEventListener("click", sendMessage);
      messageInput.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          sendMessage();
        } else {
          sendTyping();
        }
      });

      function addMessage(sender, text, isSelf, time) {
        const msgDiv = document.createElement("div");
        msgDiv.className = "message" + (isSelf ? " self" : "");
        const timeString = `<span class="timestamp">${time.toLocaleTimeString()}</span>`;
        msgDiv.innerHTML = `<strong>${sender}:</strong> ${text} ${timeString}`;
        chatArea.appendChild(msgDiv);
        chatArea.scrollTop = chatArea.scrollHeight;
        if (!isSelf) playNotificationSound();
        // Self-destruct
        setTimeout(() => {
          if (chatArea.contains(msgDiv)) {
            chatArea.removeChild(msgDiv);
          }
        }, selfDestructTime * 60000);
      }

      function sendTyping() {
        if (dataChannel && dataChannel.readyState === "open" && !typingSent) {
          const msg = { type: "typing", name: userName };
          dataChannel.send(JSON.stringify(msg));
          typingSent = true;
          setTimeout(() => {
            typingSent = false;
          }, 3000);
        }
      }

      function showTypingIndicator(sender) {
        typingIndicator.textContent = sender + " is typing...";
        clearTimeout(typingTimeout);
        typingTimeout = setTimeout(() => {
          typingIndicator.textContent = "";
        }, 3000);
      }

      /************************************************************
       * 11) Chat Utilities (clear, notifications, etc.)
       ************************************************************/
      function playNotificationSound() {
        // Very short silent audio to avoid big downloads
        const audio = new Audio("data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAIA+AAACABAAZGF0YQgAAAB");
        audio.play().catch(() => {});
      }

      clearChatButton.addEventListener("click", () => {
        collapseAllMenus();
        clearChatOptions.style.display = "flex";
      });
      clearForMeButton.addEventListener("click", () => {
        clearChatArea();
        resetClearChatOptions();
      });
      clearForEveryoneButton.addEventListener("click", () => {
        if (dataChannel && dataChannel.readyState === "open") {
          const msg = {
            type: "clearEveryone",
            name: userName,
            time: new Date().toISOString(),
          };
          dataChannel.send(JSON.stringify(msg));
        }
        clearChatArea();
        resetClearChatOptions();
      });
      cancelClearButton.addEventListener("click", resetClearChatOptions);

      function clearChatArea() {
        chatArea.innerHTML = "";
      }
      function resetClearChatOptions() {
        clearChatOptions.style.display = "none";
        clearChatButton.style.display = "inline-block";
      }

      emojiToggle.addEventListener("click", () => {
        collapseAllMenus();
        emojiMenu.style.display = emojiMenu.style.display === "flex" ? "none" : "flex";
      });
      emojiMenu.addEventListener("click", (event) => {
        if (event.target.tagName === "SPAN") {
          messageInput.value += event.target.textContent;
        }
      });

      /************************************************************
       * 12) Settings & Theme
       ************************************************************/
      openSettingsButton.addEventListener("click", () => {
        collapseAllMenus();
        settingsMenu.style.display = "block";
      });
      closeSettingsButton.addEventListener("click", () => {
        settingsMenu.style.display = "none";
      });
      saveSettingsButton.addEventListener("click", () => {
        encryptionPassphrase = encryptionPassphraseInput.value.trim() || "default";
        selfDestructTime = parseInt(selfDestructTimerInput.value) || 10;
        const theme = document.getElementById("themeSelect").value;
        if (theme === "light") {
          document.body.classList.add("light-mode");
        } else {
          document.body.classList.remove("light-mode");
        }
        encryptionKey = null; // re-derive on next encryption
        settingsMenu.style.display = "none";
      });

      function collapseAllMenus() {
        emojiMenu.style.display = "none";
        clearChatOptions.style.display = "none";
        settingsMenu.style.display = "none";
      }

      /************************************************************
       * 13) Exit Countdown
       ************************************************************/
      function startExitCountdown() {
        let timeLeft = 5;
        exitCountdown.style.display = "block";
        exitCountdown.textContent = `Returning to main page in ${timeLeft} seconds...`;
        const intervalId = setInterval(() => {
          timeLeft--;
          if (timeLeft > 0) {
            exitCountdown.textContent = `Returning to main page in ${timeLeft} seconds...`;
          } else {
            clearInterval(intervalId);
            exitCountdown.style.display = "none";
            resetAppToInitial();
          }
        }, 1000);
      }

      function resetAppToInitial() {
        chatDiv.style.display = "none";
        signalingDiv.style.display = "block";
        clearChatArea();
        messageInput.value = "";
        messageInput.disabled = false;
        sendMessageButton.disabled = false;
        roleSelection.style.display = "flex";
        nameSection.style.display = "none";
        hostSection.style.display = "none";
        peerSection.style.display = "none";
      }

      /************************************************************
       * 14) On Page Unload -> "leave" message
       ************************************************************/
      window.addEventListener("beforeunload", () => {
        if (dataChannel && dataChannel.readyState === "open") {
          const leaveMsg = {
            type: "leave",
            name: userName,
            time: new Date().toISOString(),
          };
          dataChannel.send(JSON.stringify(leaveMsg));
        }
      });

      /************************************************************
       * 15) On Page Load -> Start connecting...
       ************************************************************/
      (function init() {
        initiateServerConnection(); // Pings + connects
      })();
    </script>
  </body>
</html>
