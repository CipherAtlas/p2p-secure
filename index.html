<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <!-- Mobile-friendly viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Atlas's P2P Communication</title>
    <style>
      /* --- BASE THEME (Default Dark Mode) & Custom Themes --- */
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background-color: #0d0d0d;
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        color: #fff;
        overflow: auto;
      }
      .container {
        width: 95%;
        max-width: 800px;
        background: rgba(10, 10, 30, 0.9);
        border: 2px solid #7b2cbf;
        box-shadow: 0 0 15px #4361ee;
        border-radius: 10px;
        padding: 20px;
        box-sizing: border-box;
        margin: 10px;
        transition: box-shadow 0.3s, background 0.3s;
      }
      .container:hover {
        box-shadow: 0 0 25px #4361ee;
      }
      /* --- LOGO & ANIMATION --- */
      @keyframes glowPulse {
        0% {
          filter: drop-shadow(0 0 5px #4361ee);
        }
        50% {
          filter: drop-shadow(0 0 15px #7b2cbf);
        }
        100% {
          filter: drop-shadow(0 0 5px #4361ee);
        }
      }
      #logo {
        width: 150px;
        margin-bottom: 10px;
        animation: glowPulse 2s ease-in-out infinite;
      }
      /* --- HEADINGS & SECTIONS --- */
      h1,
      h2 {
        text-align: center;
        margin: 10px 0;
      }
      .section {
        background: rgba(20, 20, 50, 0.8);
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        box-sizing: border-box;
      }
      p {
        margin: 10px 0;
      }
      /* --- TEXTAREAS & INPUTS --- */
      textarea,
      input[type="text"],
      input[type="number"],
      select {
        width: 100%;
        border: none;
        border-radius: 5px;
        padding: 10px;
        margin-bottom: 10px;
        box-sizing: border-box;
        background: rgba(255, 255, 255, 0.1);
        color: inherit;
        font-family: inherit;
        transition: background 0.3s;
      }
      textarea:focus,
      input[type="text"]:focus,
      input[type="number"]:focus,
      select:focus {
        background: rgba(255, 255, 255, 0.2);
        outline: none;
      }
      textarea {
        height: 100px;
        resize: none;
      }
      /* --- BUTTONS --- */
      button {
        padding: 10px 20px;
        border: none;
        border-radius: 5px;
        background-color: #7b2cbf;
        color: #fff;
        font-weight: bold;
        cursor: pointer;
        margin: 5px;
        box-shadow: 0 0 10px #4361ee;
        transition: background-color 0.3s, transform 0.1s;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }
      button:hover {
        background-color: #5a189a;
      }
      button:active {
        transform: scale(0.98);
      }
      /* --- CHAT AREA --- */
      #chatArea {
        max-height: 300px;
        overflow-y: auto;
        background: rgba(20, 20, 50, 0.9);
        padding: 10px;
        border-radius: 5px;
        text-align: left;
        box-sizing: border-box;
        position: relative;
      }
      .message {
        margin: 10px 0;
        word-wrap: break-word;
        padding: 5px;
        border-radius: 5px;
        background: rgba(30, 30, 60, 0.5);
        position: relative;
      }
      .message.self {
        text-align: right;
        background: rgba(50, 50, 80, 0.5);
      }
      .timestamp {
        font-size: 0.8em;
        color: #ccc;
        margin-left: 5px;
      }
      #typingIndicator {
        font-style: italic;
        color: #ccc;
        height: 20px;
      }
      /* --- ROLE & NAME SELECTION --- */
      #roleSelection {
        display: flex;
        gap: 10px;
        justify-content: center;
        margin-bottom: 15px;
        flex-wrap: wrap;
      }
      #nameSection {
        background: rgba(20, 20, 50, 0.8);
        padding: 10px;
        border-radius: 5px;
        margin-bottom: 20px;
        text-align: center;
        display: none;
      }
      /* --- MESSAGE CONTAINER --- */
      #messageContainer {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
        gap: 5px;
      }
      #messageInput {
        flex: 1;
        height: 40px;
        line-height: 40px;
        margin: 0;
        padding: 0 10px;
        box-sizing: border-box;
      }
      #sendMessage {
        width: 40px;
        height: 40px;
        font-size: 1.2em;
        margin: 0;
        padding: 0;
        line-height: 40px;
      }
      /* --- EMOJI MENU --- */
      #emojiMenu {
        display: none;
        flex-wrap: wrap;
        background: rgba(20, 20, 50, 0.9);
        border: 1px solid #7b2cbf;
        border-radius: 5px;
        padding: 5px;
        max-height: 100px;
        overflow-y: auto;
        margin-bottom: 10px;
      }
      #emojiMenu span {
        font-size: 1.5em;
        padding: 5px;
        cursor: pointer;
        transition: background 0.2s;
      }
      #emojiMenu span:hover {
        background: rgba(123, 44, 191, 0.2);
        border-radius: 3px;
      }
      /* --- CLEAR CHAT OPTIONS --- */
      #clearChatOptions {
        display: none;
        gap: 10px;
        margin: 5px 0;
      }
      /* --- SETTINGS MENU --- */
      #settingsMenu {
        background: rgba(20, 20, 50, 0.9);
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        box-sizing: border-box;
        display: none;
      }
      /* --- FILE SHARING --- */
      #fileShareContainer {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 10px;
      }
      #fileShareButton {
        padding: 8px 16px;
        background-color: #4361ee;
      }
      #fileInput {
        display: none;
      }
      .progressBar {
        width: 100%;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 5px;
        overflow: hidden;
        margin-top: 5px;
      }
      .progressBar div {
        height: 8px;
        background: #7b2cbf;
        width: 0%;
        transition: width 0.3s;
      }
      /* --- USER AVATAR --- */
      .avatar {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        object-fit: cover;
        margin-right: 5px;
      }
      /* --- LIGHT MODE OVERRIDES --- */
      body.light-mode {
        background-color: #f0f0f0;
        color: #000;
      }
      body.light-mode .container {
        background: rgba(245, 245, 245, 0.9);
        box-shadow: 0 0 15px #999;
        color: #000;
      }
      body.light-mode .section {
        background: rgba(230, 230, 230, 0.8);
        color: #000;
      }
      body.light-mode textarea,
      body.light-mode input[type="text"],
      body.light-mode input[type="number"],
      body.light-mode select {
        background: rgba(255, 255, 255, 0.8);
        color: #000;
      }
      body.light-mode button {
        background-color: #7b2cbf;
        color: #fff;
      }
      body.light-mode #emojiMenu {
        background: rgba(230, 230, 230, 0.9);
        color: #000;
      }
      body.light-mode #chatArea {
        background: #fff;
        color: #000;
      }
      body.light-mode #typingIndicator {
        color: #333;
      }
      body.light-mode .message {
        color: #000;
      }
      body.light-mode .message.self {
        color: #000;
      }
      body.light-mode .timestamp {
        color: #666;
      }
      body.light-mode #connectionStatus {
        color: #000;
      }
      body.light-mode #settingsMenu,
      body.light-mode #settingsMenu label,
      body.light-mode #settingsMenu input,
      body.light-mode #settingsMenu select,
      body.light-mode #settingsMenu button {
        background: #fff !important;
        color: #000 !important;
        border: 1px solid #ccc;
      }
      /* --- ADDITIONAL CUSTOM THEMES --- */
      body.theme-blue {
        background-color: #003366;
        color: #ffffff;
      }
      body.theme-blue .container {
        background: #002244;
        border-color: #0055aa;
        box-shadow: 0 0 15px #0055aa;
        color: #ffffff;
      }
      body.theme-green {
        background-color: #004d00;
        color: #ffffff;
      }
      body.theme-green .container {
        background: #003300;
        border-color: #008000;
        box-shadow: 0 0 15px #008000;
        color: #ffffff;
      }
      body.theme-red {
        background-color: #660000;
        color: #ffffff;
      }
      body.theme-red .container {
        background: #440000;
        border-color: #aa0000;
        box-shadow: 0 0 15px #aa0000;
        color: #ffffff;
      }
      /* --- EXIT COUNTDOWN --- */
      #exitCountdown {
        display: none;
        text-align: center;
        font-size: 1.2em;
        margin-top: 10px;
      }
      /* --- CONNECTION STATUS & CLIENT ID --- */
      #connectionStatus {
        text-align: center;
        margin-bottom: 10px;
        font-weight: bold;
      }
      #clientIdDisplay {
        text-align: center;
        margin: 5px 0;
        font-size: 1.1em;
      }
      #serverStatus {
        text-align: center;
        margin-bottom: 10px;
        font-style: italic;
      }
      /* --- RESPONSIVE (MOBILE) --- */
      @media (max-width: 600px) {
        .container {
          padding: 15px;
        }
        #roleSelection {
          flex-direction: column;
        }
        button {
          width: 100%;
          margin: 5px 0;
        }
        #messageContainer {
          flex-direction: row;
        }
        #sendMessage {
          width: 40px;
          height: 40px;
        }
        #chatArea {
          max-height: 200px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Logo -->
      <div style="text-align: center">
        <img id="logo" src="image.webp" alt="Atlas's P2P Communication Logo" />
      </div>
      <h1>Atlas's P2P Communication</h1>
      <!-- Server Status -->
      <div id="serverStatus"></div>
      <!-- Signaling Section -->
      <div id="signaling" class="section">
        <!-- Role Selection -->
        <div id="roleSelection">
          <button id="startHost">Start as Host</button>
          <button id="joinHost">Join as Peer</button>
        </div>
        <!-- Display Name & Avatar Input Section -->
        <div id="nameSection">
          <img
            id="avatarPreview"
            class="avatar"
            src="default-avatar.png"
            alt="Avatar"
            style="display: none"
          />
          <input
            type="text"
            id="userNameInput"
            placeholder="Enter Your Display Name"
          />
          <button id="setUserName">Set Name</button>
        </div>
        <!-- Client ID Display -->
        <div id="clientIdDisplay" style="display: none">
          <strong>Your ID:</strong> <span id="clientIdValue">N/A</span>
        </div>
        <!-- Host Input -->
        <div id="hostSection" style="display: none">
          <p><strong>Peer's ID:</strong></p>
          <input
            type="text"
            id="peerIdInput"
            placeholder="Enter the peer's ID"
          />
          <button id="callPeer">Connect to Peer</button>
        </div>
        <!-- Peer Waiting Message -->
        <div id="peerSection" style="display: none">
          <p>Waiting for incoming call from the Host...</p>
        </div>
      </div>
      <!-- Chat Section -->
      <div id="chat" class="section" style="display: none">
        <h2 id="chatHeader">Chat</h2>
        <div id="connectionStatus">Status: Connecting...</div>
        <!-- Chat Display Area -->
        <div id="chatArea"></div>
        <div id="typingIndicator"></div>
        <!-- Message Input Area -->
        <div id="messageContainer">
          <input
            type="text"
            id="messageInput"
            placeholder="Type your message here..."
          />
          <button id="sendMessage">‚û§</button>
        </div>
        <!-- File Sharing Controls -->
        <div id="fileShareContainer">
          <button id="fileShareButton">Share File</button>
          <input type="file" id="fileInput" />
        </div>
        <!-- Menu Options: Emoji, Settings, Clear Chat -->
        <div
          style="
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
            flex-wrap: wrap;
          "
        >
          <button id="emojiToggle">Emoji</button>
          <button id="openSettings">Settings</button>
          <button id="clearChat">Clear Chat</button>
        </div>
        <!-- Emoji Menu -->
        <div id="emojiMenu">
          <span>üòÄ</span>
          <span>üòÇ</span>
          <span>üòç</span>
          <span>üò¢</span>
          <span>üò°</span>
          <span>üëç</span>
          <span>üëé</span>
          <span>üôè</span>
          <span>üéâ</span>
          <span>ü§î</span>
        </div>
        <!-- Clear Chat Options -->
        <div id="clearChatOptions">
          <button id="clearForMe">Clear for Me</button>
          <button id="clearForEveryone">Clear for Everyone</button>
          <button id="cancelClear">Cancel</button>
        </div>
        <!-- Exit Countdown -->
        <div id="exitCountdown"></div>
      </div>
      <!-- Settings Menu -->
      <div id="settingsMenu" class="section">
        <h2>Settings</h2>
        <label>Encryption Passphrase:</label>
        <input
          type="text"
          id="encryptionPassphraseInput"
          placeholder="Enter passphrase"
          value="default"
        />
        <label>Self-Destruct Timer (minutes):</label>
        <input type="number" id="selfDestructTimerInput" value="10" min="1" />
        <label>Chat Background:</label>
        <select id="themeSelect">
          <option value="default">Default (Dark Mode)</option>
          <option value="light">Light Background</option>
          <option value="theme-blue">Blue Background</option>
          <option value="theme-green">Green Background</option>
          <option value="theme-red">Red Background</option>
        </select>
        <label>Notification Sound:</label>
        <select id="notificationSoundSelect">
          <option value="default">Default</option>
          <option value="chime">Chime</option>
          <option value="beep">Beep</option>
        </select>
        <label>Upload Avatar:</label>
        <input type="file" id="avatarInput" accept="image/*" />
        <button id="saveSettings">Save Settings</button>
        <button id="closeSettings">Close</button>
      </div>
    </div>
    <script>
      /************************************************************
       * 1) Server Wake-Up & Connecting Animation
       ************************************************************/
      const SIGNALING_SERVER_URL = "wss://p2p-secure-server.onrender.com";
      const HTTP_WAKE_URL = "https://p2p-secure-server.onrender.com";
      const serverStatus = document.getElementById("serverStatus");
      let connectingDotsInterval;
      let connectionTimeout;
      function startConnectingAnimation() {
        let dotCount = 0;
        connectingDotsInterval = setInterval(() => {
          dotCount = (dotCount % 3) + 1;
          let dots = ".".repeat(dotCount);
          serverStatus.textContent = "Connecting" + dots;
        }, 500);
      }
      function stopConnectingAnimation() {
        clearInterval(connectingDotsInterval);
      }
      function showLongWaitMessage() {
        serverStatus.textContent =
          "Still connecting... The server may be waking up. Please keep waiting or refresh the page.";
      }
      function initiateServerConnection() {
        startConnectingAnimation();
        connectionTimeout = setTimeout(showLongWaitMessage, 10000);
        fetch(HTTP_WAKE_URL)
          .then(() => {
            connectToSignalingServer();
          })
          .catch(() => {
            connectToSignalingServer();
          });
      }
      /************************************************************
       * 2) Connect to Signaling Server via WebSocket
       ************************************************************/
      let socket;
      let clientId = null;
      let userName = "Anonymous";
      let selectedRole = null;
      let userAvatar = ""; // Base64 data URL for avatar
      function connectToSignalingServer() {
        socket = new WebSocket(SIGNALING_SERVER_URL);
        socket.onopen = () => {
          console.log("WebSocket: Connected.");
          stopConnectingAnimation();
          clearTimeout(connectionTimeout);
          serverStatus.textContent = "Connected to server!";
          setTimeout(() => {
            serverStatus.textContent = "";
          }, 2000);
        };
        socket.onmessage = (event) => {
          const msg = JSON.parse(event.data);
          handleSignalingMessage(msg);
        };
        socket.onerror = (err) => {
          console.error("WebSocket error:", err);
          stopConnectingAnimation();
          serverStatus.textContent =
            "Error connecting. The server might be waking up; please wait or refresh.";
        };
        socket.onclose = () => {
          console.warn("Socket closed.");
          stopConnectingAnimation();
          serverStatus.textContent =
            "Disconnected. Server might be sleeping. Refresh or wait.";
        };
      }
      function handleSignalingMessage(msg) {
        if (msg.type === "welcome") {
          clientId = msg.clientId;
          clientIdValue.textContent = clientId;
          document.getElementById("clientIdDisplay").style.display = "block";
        } else {
          switch (msg.type) {
            case "offer":
              onOffer(msg.from, msg.data);
              break;
            case "answer":
              onAnswer(msg.from, msg.data);
              break;
            case "candidate":
              onCandidate(msg.from, msg.data);
              break;
            case "read":
              updateReadReceipt(msg.messageId, msg.name);
              break;
            case "file":
              handleIncomingFile(msg);
              break;
            default:
              console.log("Unknown WS message:", msg);
          }
        }
      }
      function sendToServer(target, type, data) {
        socket.send(JSON.stringify({ target, type, data }));
      }
      /************************************************************
       * 3) WebRTC / Chat Variables & Setup
       ************************************************************/
      let localConnection;
      let dataChannel;
      let peerId = "";
      let typingTimeout;
      let typingSent = false;
      let selfDestructTime = 10;
      let encryptionPassphrase = "default";
      let encryptionKey = null;
      let messageCounter = 0;
      const roleSelection = document.getElementById("roleSelection");
      const startHostButton = document.getElementById("startHost");
      const joinHostButton = document.getElementById("joinHost");
      const nameSection = document.getElementById("nameSection");
      const userNameInput = document.getElementById("userNameInput");
      const setUserNameButton = document.getElementById("setUserName");
      const clientIdDisplay = document.getElementById("clientIdDisplay");
      const clientIdValue = document.getElementById("clientIdValue");
      const hostSection = document.getElementById("hostSection");
      const peerIdInput = document.getElementById("peerIdInput");
      const callPeerButton = document.getElementById("callPeer");
      const peerSection = document.getElementById("peerSection");
      const chatDiv = document.getElementById("chat");
      const chatHeader = document.getElementById("chatHeader");
      const connectionStatus = document.getElementById("connectionStatus");
      const chatArea = document.getElementById("chatArea");
      const typingIndicator = document.getElementById("typingIndicator");
      const messageInput = document.getElementById("messageInput");
      const sendMessageButton = document.getElementById("sendMessage");
      const clearChatButton = document.getElementById("clearChat");
      const clearChatOptions = document.getElementById("clearChatOptions");
      const clearForMeButton = document.getElementById("clearForMe");
      const clearForEveryoneButton =
        document.getElementById("clearForEveryone");
      const cancelClearButton = document.getElementById("cancelClear");
      const emojiToggle = document.getElementById("emojiToggle");
      const emojiMenu = document.getElementById("emojiMenu");
      const openSettingsButton = document.getElementById("openSettings");
      const settingsMenu = document.getElementById("settingsMenu");
      const encryptionPassphraseInput = document.getElementById(
        "encryptionPassphraseInput"
      );
      const selfDestructTimerInput = document.getElementById(
        "selfDestructTimerInput"
      );
      const saveSettingsButton = document.getElementById("saveSettings");
      const closeSettingsButton = document.getElementById("closeSettings");
      const exitCountdown = document.getElementById("exitCountdown");
      const signalingDiv = document.getElementById("signaling");
      const fileShareButton = document.getElementById("fileShareButton");
      const fileInput = document.getElementById("fileInput");
      const avatarInput = document.getElementById("avatarInput");
      /************************************************************
       * 4) Role Selection & Name
       ************************************************************/
      startHostButton.addEventListener("click", () => {
        selectedRole = "host";
        if (userName === "Anonymous") {
          nameSection.style.display = "block";
        } else {
          showHostUI();
        }
      });
      joinHostButton.addEventListener("click", () => {
        selectedRole = "peer";
        if (userName === "Anonymous") {
          nameSection.style.display = "block";
        } else {
          showPeerUI();
        }
      });
      setUserNameButton.addEventListener("click", () => {
        const name = userNameInput.value.trim();
        if (name) {
          userName = name;
          nameSection.style.display = "none";
          if (selectedRole === "host") {
            showHostUI();
          } else {
            showPeerUI();
          }
        } else {
          alert("Please enter a valid display name.");
        }
      });
      function showHostUI() {
        roleSelection.style.display = "none";
        hostSection.style.display = "block";
        peerSection.style.display = "none";
      }
      function showPeerUI() {
        roleSelection.style.display = "none";
        peerSection.style.display = "block";
        hostSection.style.display = "none";
      }
      /************************************************************
       * 5) Creating the PeerConnection & DataChannel
       ************************************************************/
      function createPeerConnection() {
        localConnection = new RTCPeerConnection({
          iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
        });
        localConnection.onicecandidate = (event) => {
          if (event.candidate) {
            sendToServer(peerId, "candidate", event.candidate);
          }
        };
        localConnection.oniceconnectionstatechange = () => {
          connectionStatus.textContent =
            "Status: " + localConnection.iceConnectionState;
          if (
            localConnection.iceConnectionState === "disconnected" ||
            localConnection.iceConnectionState === "failed"
          ) {
            console.log("ICE disconnected/failed. Attempting restart...");
            localConnection.restartIce();
          }
        };
        localConnection.ondatachannel = (event) => {
          dataChannel = event.channel;
          setupDataChannel();
        };
      }
      function createDataChannel() {
        dataChannel = localConnection.createDataChannel("chat");
        setupDataChannel();
      }
      function setupDataChannel() {
        dataChannel.onopen = () => {
          console.log("Data channel open");
          signalingDiv.style.display = "none";
          chatDiv.style.display = "block";
        };
        dataChannel.onmessage = (event) => {
          let incoming;
          try {
            incoming = JSON.parse(event.data);
          } catch (error) {
            console.error(
              "Failed to parse incoming message:",
              error,
              event.data
            );
            return; // Skip processing if JSON parsing fails
          }

          if (incoming.type === "chat") {
            const formatted = parseMarkdown(incoming.text);
            addMessage(
              incoming.name,
              formatted,
              false,
              new Date(incoming.time),
              incoming.messageId,
              incoming.avatar
            );
            sendReadReceipt(incoming.messageId);
          } else if (incoming.type === "file") {
            handleIncomingFile(incoming);
          } else {
            handleIncomingMessage(incoming);
          }
        };
      }
      /************************************************************
       * 6) Host Flow: createOffer -> send to Peer
       ************************************************************/
      async function startHostCall() {
        createPeerConnection();
        createDataChannel();
        try {
          const offer = await localConnection.createOffer();
          await localConnection.setLocalDescription(offer);
          sendToServer(peerId, "offer", offer);
        } catch (err) {
          console.error("Error creating offer:", err);
        }
      }
      callPeerButton.addEventListener("click", () => {
        peerId = peerIdInput.value.trim();
        if (!peerId) {
          alert("Please enter the peer's ID.");
          return;
        }
        startHostCall();
      });
      /************************************************************
       * 7) Peer Flow: onOffer -> setRemote -> createAnswer -> send
       ************************************************************/
      async function onOffer(from, offer) {
        peerId = from;
        createPeerConnection();
        try {
          await localConnection.setRemoteDescription(offer);
          const answer = await localConnection.createAnswer();
          await localConnection.setLocalDescription(answer);
          sendToServer(peerId, "answer", answer);
        } catch (err) {
          console.error("Error handling offer:", err);
        }
      }
      async function onAnswer(from, answer) {
        try {
          await localConnection.setRemoteDescription(answer);
          console.log("Remote desc set (host side)");
        } catch (err) {
          console.error("Error setting remote desc:", err);
        }
      }
      async function onCandidate(from, candidate) {
        try {
          await localConnection.addIceCandidate(candidate);
        } catch (err) {
          console.error("Error adding ICE candidate:", err);
        }
      }
      /************************************************************
       * 8) Incoming Chat & System Messages
       ************************************************************/
      function handleIncomingMessage(msg) {
        if (msg.type === "chat") {
          const formatted = parseMarkdown(msg.text);
          addMessage(
            msg.name,
            formatted,
            false,
            new Date(msg.time),
            msg.messageId,
            msg.avatar
          );
          sendReadReceipt(msg.messageId);
        } else if (msg.type === "typing") {
          showTypingIndicator(msg.name);
        } else if (msg.type === "clearEveryone") {
          clearChatArea();
          const sysMsg = document.createElement("div");
          sysMsg.className = "message";
          sysMsg.style.fontStyle = "italic";
          sysMsg.textContent = "Chat was cleared by " + msg.name;
          chatArea.appendChild(sysMsg);
          chatArea.scrollTop = chatArea.scrollHeight;
        } else if (msg.type === "leave") {
          const sysMsg = document.createElement("div");
          sysMsg.className = "message";
          sysMsg.style.fontStyle = "italic";
          sysMsg.textContent = msg.name + " has left the chat.";
          chatArea.appendChild(sysMsg);
          chatArea.scrollTop = chatArea.scrollHeight;
          messageInput.disabled = true;
          sendMessageButton.disabled = true;
          startExitCountdown();
        }
      }
      /************************************************************
       * 9) End-to-End Encryption
       ************************************************************/
      async function deriveKey(passphrase) {
        const enc = new TextEncoder();
        const keyMaterial = await window.crypto.subtle.importKey(
          "raw",
          enc.encode(passphrase),
          { name: "PBKDF2" },
          false,
          ["deriveKey"]
        );
        return window.crypto.subtle.deriveKey(
          {
            name: "PBKDF2",
            salt: enc.encode("fixedSalt"),
            iterations: 100000,
            hash: "SHA-256",
          },
          keyMaterial,
          { name: "AES-GCM", length: 256 },
          false,
          ["encrypt", "decrypt"]
        );
      }
      async function encryptMessage(plaintext) {
        if (!encryptionKey) {
          encryptionKey = await deriveKey(encryptionPassphrase);
        }
        const enc = new TextEncoder();
        const iv = window.crypto.getRandomValues(new Uint8Array(12));
        const encrypted = await window.crypto.subtle.encrypt(
          { name: "AES-GCM", iv },
          encryptionKey,
          enc.encode(plaintext)
        );
        return {
          iv: Array.from(iv),
          ciphertext: Array.from(new Uint8Array(encrypted)),
        };
      }
      async function decryptMessage(encryptedObj) {
        if (!encryptionKey) {
          encryptionKey = await deriveKey(encryptionPassphrase);
        }
        const { iv, ciphertext } = encryptedObj;
        const dec = new TextDecoder();
        const decrypted = await window.crypto.subtle.decrypt(
          { name: "AES-GCM", iv: new Uint8Array(iv) },
          encryptionKey,
          new Uint8Array(ciphertext)
        );
        return dec.decode(decrypted);
      }
      /************************************************************
       * 10) Sending Chat Messages, File, and Read Receipts
       ************************************************************/
      async function sendMessage() {
        const text = messageInput.value.trim();
        if (text && dataChannel && dataChannel.readyState === "open") {
          try {
            const encryptedData = await encryptMessage(text);
            const messageId = "msg-" + Date.now() + "-" + messageCounter++;
            const msg = {
              type: "chat",
              name: userName,
              text: text,
              encrypted: true,
              data: encryptedData,
              time: new Date().toISOString(),
              messageId: messageId,
              avatar: userAvatar,
            };
            dataChannel.send(JSON.stringify(msg));
            const formatted = parseMarkdown(text);
            addMessage(
              userName,
              formatted,
              true,
              new Date(),
              messageId,
              userAvatar
            );
            messageInput.value = "";
          } catch (err) {
            console.error("Encryption error:", err);
          }
        }
      }
      sendMessageButton.addEventListener("click", sendMessage);
      messageInput.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          sendMessage();
        } else {
          sendTyping();
        }
      });
      function addMessage(sender, text, isSelf, time, messageId, avatar) {
        const msgDiv = document.createElement("div");
        msgDiv.className = "message" + (isSelf ? " self" : "");
        msgDiv.dataset.messageId = messageId;
        let avatarHTML = "";
        if (avatar) {
          avatarHTML = `<img src="${avatar}" class="avatar" alt="avatar">`;
        }
        const timeString = `<span class="timestamp">${time.toLocaleTimeString()}</span>`;
        msgDiv.innerHTML = `${avatarHTML}<strong>${sender}:</strong> ${text} ${timeString}`;
        chatArea.appendChild(msgDiv);
        chatArea.scrollTop = chatArea.scrollHeight;
        if (!isSelf) playNotificationSound();
        setTimeout(() => {
          if (chatArea.contains(msgDiv)) {
            chatArea.removeChild(msgDiv);
          }
        }, selfDestructTime * 60000);
      }
      function sendTyping() {
        if (dataChannel && dataChannel.readyState === "open" && !typingSent) {
          const msg = { type: "typing", name: userName };
          dataChannel.send(JSON.stringify(msg));
          typingSent = true;
          setTimeout(() => {
            typingSent = false;
          }, 3000);
        }
      }
      function showTypingIndicator(sender) {
        typingIndicator.textContent = sender + " is typing...";
        clearTimeout(typingTimeout);
        typingTimeout = setTimeout(() => {
          typingIndicator.textContent = "";
        }, 3000);
      }
      function sendReadReceipt(messageId) {
        if (dataChannel && dataChannel.readyState === "open") {
          const msg = {
            type: "read",
            messageId: messageId,
            name: userName,
            time: new Date().toISOString(),
          };
          dataChannel.send(JSON.stringify(msg));
        }
      }
      function updateReadReceipt(messageId, readerName) {
        const messages = document.querySelectorAll(
          `.message[data-message-id="${messageId}"] .readReceipt`
        );
        messages.forEach((r) => {
          r.textContent = "Read by " + readerName;
        });
      }
      clearChatButton.addEventListener("click", () => {
        collapseAllMenus();
        clearChatOptions.style.display = "flex";
      });
      clearForMeButton.addEventListener("click", () => {
        clearChatArea();
        resetClearChatOptions();
      });
      clearForEveryoneButton.addEventListener("click", () => {
        if (dataChannel && dataChannel.readyState === "open") {
          const msg = {
            type: "clearEveryone",
            name: userName,
            time: new Date().toISOString(),
          };
          dataChannel.send(JSON.stringify(msg));
        }
        clearChatArea();
        resetClearChatOptions();
      });
      cancelClearButton.addEventListener("click", resetClearChatOptions);
      function clearChatArea() {
        chatArea.innerHTML = "";
      }
      function resetClearChatOptions() {
        clearChatOptions.style.display = "none";
        clearChatButton.style.display = "inline-block";
      }
      emojiToggle.addEventListener("click", () => {
        collapseAllMenus();
        emojiMenu.style.display =
          emojiMenu.style.display === "flex" ? "none" : "flex";
      });
      emojiMenu.addEventListener("click", (event) => {
        if (event.target.tagName === "SPAN") {
          messageInput.value += event.target.textContent;
        }
      });
      openSettingsButton.addEventListener("click", () => {
        collapseAllMenus();
        settingsMenu.style.display = "block";
      });
      closeSettingsButton.addEventListener("click", () => {
        settingsMenu.style.display = "none";
      });
      saveSettingsButton.addEventListener("click", () => {
        encryptionPassphrase =
          encryptionPassphraseInput.value.trim() || "default";
        selfDestructTime = parseInt(selfDestructTimerInput.value) || 10;
        const theme = document.getElementById("themeSelect").value;
        document.body.className = "";
        if (theme === "light") {
          document.body.classList.add("light-mode");
        } else if (theme !== "default") {
          document.body.classList.add(theme);
        }
        encryptionKey = null;
        settingsMenu.style.display = "none";
      });
      function collapseAllMenus() {
        emojiMenu.style.display = "none";
        clearChatOptions.style.display = "none";
        settingsMenu.style.display = "none";
      }
      function startExitCountdown() {
        let timeLeft = 5;
        exitCountdown.style.display = "block";
        exitCountdown.textContent = `Returning to main page in ${timeLeft} seconds...`;
        const intervalId = setInterval(() => {
          timeLeft--;
          if (timeLeft > 0) {
            exitCountdown.textContent = `Returning to main page in ${timeLeft} seconds...`;
          } else {
            clearInterval(intervalId);
            exitCountdown.style.display = "none";
            resetAppToInitial();
          }
        }, 1000);
      }
      function resetAppToInitial() {
        chatDiv.style.display = "none";
        signalingDiv.style.display = "block";
        clearChatArea();
        messageInput.value = "";
        messageInput.disabled = false;
        sendMessageButton.disabled = false;
        roleSelection.style.display = "flex";
        nameSection.style.display = "none";
        hostSection.style.display = "none";
        peerSection.style.display = "none";
      }
      window.addEventListener("beforeunload", () => {
        if (dataChannel && dataChannel.readyState === "open") {
          const leaveMsg = {
            type: "leave",
            name: userName,
            time: new Date().toISOString(),
          };
          dataChannel.send(JSON.stringify(leaveMsg));
        }
      });
      /************************************************************
       * 11) File Sharing Implementation
       ************************************************************/
      fileShareButton.addEventListener("click", () => {
        fileInput.click();
      });
      fileInput.addEventListener("change", () => {
        const file = fileInput.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = async (e) => {
          const fileData = e.target.result;
          const messageId = "file-" + Date.now();
          const fileMsg = {
            type: "file",
            name: userName,
            fileName: file.name,
            fileType: file.type,
            fileSize: file.size,
            fileData: fileData,
            time: new Date().toISOString(),
            messageId: messageId,
            avatar: userAvatar,
          };
          if (dataChannel && dataChannel.readyState === "open") {
            dataChannel.send(JSON.stringify(fileMsg));
            displayFileMessage(fileMsg, true);
          }
        };
        reader.readAsDataURL(file);
      });
      function displayFileMessage(fileMsg, isSelf) {
        const msgDiv = document.createElement("div");
        msgDiv.className = "message" + (isSelf ? " self" : "");
        msgDiv.dataset.messageId = fileMsg.messageId;
        let avatarHTML = "";
        if (fileMsg.avatar) {
          avatarHTML = `<img src="${fileMsg.avatar}" class="avatar" alt="avatar">`;
        }
        const timeString = `<span class="timestamp">${new Date(
          fileMsg.time
        ).toLocaleTimeString()}</span>`;
        let filePreview = "";
        if (fileMsg.fileType.startsWith("image/")) {
          filePreview = `<br><img src="${fileMsg.fileData}" alt="${fileMsg.fileName}" style="max-width:200px; border-radius:5px;">`;
        } else if (fileMsg.fileType.startsWith("text/")) {
          filePreview = `<br><textarea readonly style="width:100%; height:80px;">${atob(
            fileMsg.fileData.split(",")[1]
          )}</textarea>`;
        } else {
          filePreview = `<br><a href="${fileMsg.fileData}" download="${fileMsg.fileName}">Download ${fileMsg.fileName}</a>`;
        }
        msgDiv.innerHTML = `${avatarHTML}<strong>${fileMsg.name} shared a file:</strong> ${fileMsg.fileName} ${timeString} ${filePreview}`;
        chatArea.appendChild(msgDiv);
        chatArea.scrollTop = chatArea.scrollHeight;
      }
      function handleIncomingFile(msg) {
        displayFileMessage(msg, false);
      }
      /************************************************************
       * 12) Markdown Parsing Function
       ************************************************************/
      function parseMarkdown(text) {
        let formatted = text;
        formatted = formatted.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
        formatted = formatted.replace(/\*(.+?)\*/g, "<em>$1</em>");
        formatted = formatted.replace(/`(.+?)`/g, "<code>$1</code>");
        return formatted;
      }
      /************************************************************
       * 13) Avatar Upload
       ************************************************************/
      avatarInput.addEventListener("change", () => {
        const file = avatarInput.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
          userAvatar = e.target.result;
          document.getElementById("avatarPreview").src = userAvatar;
          document.getElementById("avatarPreview").style.display =
            "inline-block";
        };
        reader.readAsDataURL(file);
      });
      /************************************************************
       * 14) Exit Countdown & Initialization
       ************************************************************/
      (function init() {
        initiateServerConnection();
      })();
    </script>
  </body>
</html>
